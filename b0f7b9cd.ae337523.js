(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{162:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return r})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return p}));var a=t(2),o=t(10),i=(t(0),t(173)),s={id:"version-selection",title:"Version Selection"},r={id:"concepts/rpms/version-selection",isDocsHomePage:!1,title:"Version Selection",description:"Constraining allowable package versions",source:"@site/docs/concepts/rpms/version-selection.md",permalink:"/antlir/docs/concepts/rpms/version-selection",editUrl:"https://github.com/facebookincubator/antlir/edit/master/website/docs/concepts/rpms/version-selection.md",sidebar:"docs",previous:{title:"Using RPMs in Images",permalink:"/antlir/docs/concepts/rpms/using-rpms-in-images"},next:{title:"Overview",permalink:"/antlir/docs/concepts/rpms/overview"}},l=[{value:"Constraining allowable package versions",id:"constraining-allowable-package-versions",children:[]},{value:"Concepts",id:"concepts",children:[{value:"Package group",id:"package-group",children:[]},{value:"Version policy",id:"version-policy",children:[]},{value:"Version set",id:"version-set",children:[]}]},{value:"How do I define a policy for my packages?",id:"how-do-i-define-a-policy-for-my-packages",children:[]},{value:"What happens when a version updates?",id:"what-happens-when-a-version-updates",children:[]},{value:"How often do versions update?",id:"how-often-do-versions-update",children:[]},{value:"How do allowable versions affect Buck dependencies?",id:"how-do-allowable-versions-affect-buck-dependencies",children:[]},{value:"Why do we only control versions for explicitly named packages?",id:"why-do-we-only-control-versions-for-explicitly-named-packages",children:[]},{value:"Future: some version-locks are part of the snapshot, apply always",id:"future-some-version-locks-are-part-of-the-snapshot-apply-always",children:[]}],c={rightToc:l};function p(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"constraining-allowable-package-versions"},"Constraining allowable package versions"),Object(i.b)("p",null,"Image builds\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/antlir/docs/concepts/rpms/overview#rpms-come-from-snapshots"}),"install RPMs from repo snapshots"),".\nThese snapshots sometimes contain broken or bleeding-edge versions of packages."),Object(i.b)("p",null,"We maintain automation, which periodically commits lists of allowable versions\nto fbcode for each ",Object(i.b)("em",{parentName:"p"},"package group"),", by evaluating a ",Object(i.b)("em",{parentName:"p"},"version policy")," for the\ngroup. To address the fact that different applications may call for different\npackage version mixes, fbcode may contain multiple named ",Object(i.b)("em",{parentName:"p"},"version sets"),", each\npicking different version policies. The italicized concepts are thoroughly\nexplained below."),Object(i.b)("p",null,"Versions for packages not included in any group will be whatever ",Object(i.b)("inlineCode",{parentName:"p"},"yum")," / ",Object(i.b)("inlineCode",{parentName:"p"},"dnf"),'\nselect, which is usually "latest" or "whatever is required by the package that\ndepends on it".'),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"IMPORTANT:")," Allowable versions for a package ",Object(i.b)("strong",{parentName:"p"},"ONLY")," apply if your\n",Object(i.b)("inlineCode",{parentName:"p"},"image.layer")," explicitly installs that package. So if your layer installs X,\nwhich depends on Y, and both have a version policy, the version policy for Y\nwill only apply if your layer also explicitly installs Y. Otherwise, your\nversion of X will be per policy, and Y will be whatever ",Object(i.b)("inlineCode",{parentName:"p"},"yum")," / ",Object(i.b)("inlineCode",{parentName:"p"},"dnf")," decide\n(i.e. latest acceptable per X's dependency spec). There's a\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#why-do-we-only-control-versions-for-explicitly-named-packages"}),"later section"),"\nexplaining this rule."),Object(i.b)("h2",{id:"concepts"},"Concepts"),Object(i.b)("h3",{id:"package-group"},"Package group"),Object(i.b)("p",null,"A list of related packages, all of which must always have the same installed\nversion (and ought to be installed in one transaction). For example, ",Object(i.b)("inlineCode",{parentName:"p"},"systemd"),",\n",Object(i.b)("inlineCode",{parentName:"p"},"systemd-libs"),", and ",Object(i.b)("inlineCode",{parentName:"p"},"systemd-devel")," must be in sync. Each package may be in at\nmost one package group. Package groups can be defined: manually, or via\nslowroll:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"packages": ["a", "b", "c"]')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"packages": {"source": "slowroll", "name": "systemd-packages"}')," \u2014 this only\nworks for multi-package slowrolls.")),Object(i.b)("h3",{id:"version-policy"},"Version policy"),Object(i.b)("p",null,"For a package group, a policy examines the versions available in the RPM\nsnapshot, and looks at some other data source to pick the versions (possibly\nplural!) to allow installing into images. Available policies:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},'"significant_fraction_of_hosts"'),": Picks versions, which are on at least 20%\nof the hosts installing this RPM. It is an error if none of the versions are\ninstalled on enough hosts, or if less than 1 million hosts install this\npackage (in the given architecture). Exact thresholds are subject to change,\nconsult the code.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A manual version spec: :"),Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'{\n   "policy": "manual",\n   "versions": {"x86_64": [\n      "VERSION1-RELEASE1",\n      {"epoch": 3, "version": "VER2", "release": "REL2"},\n      ...\n   ]}\n}\n')),Object(i.b)("p",{parentName:"li"},'For each architecture, allows only the specified RPM epoch-version-releases to\nbe installed for your package group. If you use the "version-release"\nshorthand, we try to will resolve the epoch from the RPM snapshot, and error\nif more than one package matches. You can specify additional architectures,\ne.g. ',Object(i.b)("inlineCode",{parentName:"p"},"i686")," is how we handle 32-bit binary support on CentOS7."))),Object(i.b)("p",null,"It is an error if none of the versions suggested by a policy are available in\nthe snapshot."),Object(i.b)("p",null,'When a policy encounters an error for a package, the package will "fail open",\nallowing the installation of any version. This behavior is deliberate \u2014 there is\nno value in preserving a stale version-lock, so we might as well have the diff\ncheck whether trunk now works without locks. The automatic diff description will\nsuggest updating or deleting the corresponding package group policy to allow\ninstalling any version from the repo snapshot.'),Object(i.b)("h3",{id:"version-set"},"Version set"),Object(i.b)("p",null,"We may want to build several flavors of images, with more or less well-tested\npackage mixes. Every image is built using allowable versions from a specific\nversion set name. The currently available names are:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"tw_jobs"),": Versions stable enough to safely include in a normal release\nprocess for a Tupperware job \u2014 e.g. a Conveyor / SF canary, followed by a\ngradual failure-reverting job update to use the new packages. Although each\njob owner is responsible for testing your job, avoid shipping something so\nunvetted that it will break push for many teams at once. This version set is\nnot directly related to Slowroll ",Object(i.b)("inlineCode",{parentName:"li"},'"stable"')," \u2014 see\n",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://our.intern.facebook.com/intern/wiki/Production_Engineering/OS/Slowroll/SlowrolledRPMsAndTW/#can-we-just-use-slowroll"}),"this section"),"\nfor why using Slowroll versions outside of Chef makes no sense.")),Object(i.b)("p",null,"If a package group does not set a policy for a particular version set, any\nversion in the RPM snapshot may be installed."),Object(i.b)("h2",{id:"how-do-i-define-a-policy-for-my-packages"},"How do I define a policy for my packages?"),Object(i.b)("p",null,"Add ",Object(i.b)("inlineCode",{parentName:"p"},"YOUR_GROUPNAME.json")," into\n",Object(i.b)("inlineCode",{parentName:"p"},"fbcode/antlir/rpm/allowed_versions/facebook/package_groups/")," with the\nfollowing information:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'$ jq -C . systemd.json\n{\n"packages": {\n   "source": "slowroll",\n   "name": "systemd-packages"\n},\n"version_set_to_policy": {\n   "tw_jobs": "significant_fraction_of_hosts"\n},\n"oncall": "systemd_releng"\n}\n')),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},'"packages"')," field is documented above \u2014 for single-package slowrolls, you\nshould just specify ",Object(i.b)("inlineCode",{parentName:"p"},'"packages": ["rpm-name"]'),"."),Object(i.b)("p",null,"Available policies & version set names are also documented above."),Object(i.b)("p",null,"Suggested auto-formatting is\n",Object(i.b)("inlineCode",{parentName:"p"},'name=YOUR_FILE.json cfg="$(cat "$name")" ; echo "$cfg" | jq . > "$name"'),".\nWhether for formatting, or for data model changes, we may modify your policy\nfiles without warning, while aiming to preserve their intent."),Object(i.b)("p",null,"Put up a diff with your policy and ",Object(i.b)("strong",{parentName:"p"},"wait for tests to be green"),"."),Object(i.b)("p",null,"Once your policy is committed, automation will begin generating a preferred\nversion for your package group."),Object(i.b)("h2",{id:"what-happens-when-a-version-updates"},"What happens when a version updates?"),Object(i.b)("p",null,"Your oncall will see a diff that updates a file in fbcode to contain the new\nallowable versions for you package group. Automation will land this diff is all\nbuilds & tests are green. Otherwise, your oncall is responsible for ensuring\nthat the builds & tests ",Object(i.b)("strong",{parentName:"p"},"become")," green. On-diff failures typically indicate\nthat your version bump broke somebody. Talk to that team, they'll be eager to\nhelp you fix them."),Object(i.b)("h2",{id:"how-often-do-versions-update"},"How often do versions update?"),Object(i.b)("p",null,"We refresh versions more often than we generate RPM repo snapshots. The exact\nfrequencies are subject to change, but snapshots will be ~1/week, and version\nrefreshes will happen every couple of hours (limited by fbcode diff turnaround\ntime)."),Object(i.b)("p",null,"However in some cases, a policy would only be able to pick versions that\nare not yet in the snapshot."),Object(i.b)("p",null,"In these cases, the version bump will be delayed until the next RPM snapshot."),Object(i.b)("p",null,"The practical rationale for the differing update frequencies is that testing a\nversion bump is cheap, because Buck knows the full dependency graph for these.\nTesting a new snapshot involves rebuilding & retesting the world."),Object(i.b)("h2",{id:"how-do-allowable-versions-affect-buck-dependencies"},"How do allowable versions affect Buck dependencies?"),Object(i.b)("p",null,"Every ",Object(i.b)("inlineCode",{parentName:"p"},"image.layer")," that installs any RPMs depends on an RPM repo snapshot\n(normally, this is specified via the ",Object(i.b)("inlineCode",{parentName:"p"},"build_appliance")," field, formerly we used\n",Object(i.b)("inlineCode",{parentName:"p"},"yum_from_repo_snapshot"),")."),Object(i.b)("p",null,"So, updating the snapshot rebuilds the world, which is expensive in terms of\nSandcastle capacity."),Object(i.b)("p",null,'In contrast, each package\'s "allowable versions" list is a separate target, and\nyour ',Object(i.b)("inlineCode",{parentName:"p"},"image.layer")," only depends on the targets for RPMs it explicitly installs."),Object(i.b)("p",null,"So, changing the version of a package (while leaving the snapshot fixed) will\nonly rebuild those images that explicitly install the package."),Object(i.b)("h2",{id:"why-do-we-only-control-versions-for-explicitly-named-packages"},"Why do we only control versions for explicitly named packages?"),Object(i.b)("p",null,'It seems pretty counterintuitive that for packages that are pulled in as\ndependencies, we go with "whatever ',Object(i.b)("inlineCode",{parentName:"p"},"yum")," / ",Object(i.b)("inlineCode",{parentName:"p"},"dnf"),' wants" ',Object(i.b)("strong",{parentName:"p"},"even when"),' we know\nthe subset of "better tested" versions for those packages.'),Object(i.b)("p",null,"We have a handful of reasons for having implicit versions be less locked down:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"[most important]")," We need package version bumps to be efficient in terms\nof Sandcastle capacity. This means only rebuilding images that are actually\naffected by the version bump. Buck currently does not know the dependency\nstructure of RPMs, which means that we can only have efficient re-builds if\nversion locks only affect those packages explicitly listed in ",Object(i.b)("inlineCode",{parentName:"li"},"TARGETS"),'\nfiles. If version locks also affected implicitly installed packages, then\nany version bump would need to rebuild the world, which means that we would\nonly be able to update versions at the time that we do repo snapshots, which\nis probably not what most teams want. We have a work item to try to expose\nthe RPM dependency structure to Buck, which would enable more frequent\nsnapshots, but I do not want to block the version selection work on that\nsubstantial effort. See "Map RPM dependencies onto Buck dependencies for\nefficient rebuilds on RPM updates" in ',Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://fb.quip.com/YR5sAUGA74lc"}),"https://fb.quip.com/YR5sAUGA74lc"),"."),Object(i.b)("li",{parentName:"ul"},"It is completely plausible to lock down implicitly installed packages at a\nlater date, if it proves to be a problem."),Object(i.b)("li",{parentName:"ul"},'If the latest "Y" is pulled in as a dependency of X, and the author of X is\nnot satisfied with the version of "Y", then the dependency spec for X is\nwrong. We should be fixing these types of issues at the package level.'),Object(i.b)("li",{parentName:"ul"},"Reducing the number of locked versions will generally reduce the operational\nheadaches with resolving dependency conflicts."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"[technicality]")," This mirrors Chef's behavior, in the sense that if\npackage ",Object(i.b)("inlineCode",{parentName:"li"},"X")," depends on ",Object(i.b)("inlineCode",{parentName:"li"},"Y"),", and both have slowrolls in recipes ",Object(i.b)("inlineCode",{parentName:"li"},"rX")," and\n",Object(i.b)("inlineCode",{parentName:"li"},"rY"),", and somehow only ",Object(i.b)("inlineCode",{parentName:"li"},"rX")," is executed on your Chef run (i.e. ",Object(i.b)("inlineCode",{parentName:"li"},"rX")," does not\nexplicitly depend on ",Object(i.b)("inlineCode",{parentName:"li"},"rY"),"), then you will end up with ",Object(i.b)("inlineCode",{parentName:"li"},"X")," slowrolled, but\n",Object(i.b)("inlineCode",{parentName:"li"},"Y")," unmanaged.")),Object(i.b)("h2",{id:"future-some-version-locks-are-part-of-the-snapshot-apply-always"},"Future: some version-locks are part of the snapshot, apply always"),Object(i.b)("p",null,'There is a narrow use-case, where the "latest" version in a repo snapshot is\nbad, and the breakage on hosts was mitigated using Slowroll or Chef.\nSpecifically, this handles the "accidental VIM upgrade" scenario, where ',Object(i.b)("inlineCode",{parentName:"p"},"vim"),"\nwent to 8.0 before FB was ready for it."),Object(i.b)("p",null,"For these, we'll want a separate version-lock file that is part of the snapshot,\nand that applies even to implicitly installed packages."),Object(i.b)("p",null,"This is not hard to build, but we are not prioritizing it yet."))}p.isMDXComponent=!0},173:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return u}));var a=t(0),o=t.n(a);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=o.a.createContext({}),p=function(e){var n=o.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},b=function(e){var n=p(e.components);return o.a.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},h=o.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=p(t),h=a,u=b["".concat(s,".").concat(h)]||b[h]||d[h]||i;return t?o.a.createElement(u,r(r({ref:n},c),{},{components:t})):o.a.createElement(u,r({ref:n},c))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=h;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var c=2;c<i;c++)s[c]=t[c];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,t)}h.displayName="MDXCreateElement"}}]);