(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{108:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return u}));var a=t(0),i=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function b(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=i.a.createContext({}),c=function(e){var n=i.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return i.a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},m=i.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,s=b(e,["components","mdxType","originalType","parentName"]),p=c(t),m=a,u=p["".concat(l,".").concat(m)]||p[m]||d[m]||r;return t?i.a.createElement(u,o(o({ref:n},s),{},{components:t})):i.a.createElement(u,o({ref:n},s))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,l=new Array(r);l[0]=m;var o={};for(var b in n)hasOwnProperty.call(n,b)&&(o[b]=n[b]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var s=2;s<r;s++)l[s]=t[s];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},95:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return o})),t.d(n,"toc",(function(){return b})),t.d(n,"default",(function(){return c}));var a=t(3),i=t(7),r=(t(0),t(108)),l={id:"image",title:"Image",generated:"@generated"},o={unversionedId:"api/image",id:"api/image",isDocsHomePage:!1,title:"Image",description:"This provides a more friendly UI to the image_* macros.",source:"@site/docs/api/gen-image.md",slug:"/api/image",permalink:"/antlir/docs/api/image",editUrl:"https://github.com/facebookincubator/antlir/edit/master/website/docs/api/gen-image.md",version:"current",sidebar:"docs",previous:{title:"Fetched Artifacts",permalink:"/antlir/docs/concepts/pre-built-artifacts/fetched-artifacts"},next:{title:"image.genrule_layer",permalink:"/antlir/docs/genrule-layer"}},b=[{value:"<code>clone</code>",id:"clone",children:[{value:"Trailing slashes on both paths are significant",id:"trailing-slashes-on-both-paths-are-significant",children:[]},{value:"Known deviations from perfect cloning",id:"known-deviations-from-perfect-cloning",children:[]},{value:"No UID/GID remapping is attempted",id:"no-uidgid-remapping-is-attempted",children:[]},{value:"When to use this?",id:"when-to-use-this",children:[]}]},{value:"<code>cpp_unittest</code>",id:"cpp_unittest",children:[]},{value:"<code>rust_unittest</code>",id:"rust_unittest",children:[]},{value:"<code>ensure_dir_symlink</code>",id:"ensure_dir_symlink",children:[]},{value:"<code>ensure_dirs_exist</code>",id:"ensure_dirs_exist",children:[]},{value:"<code>ensure_file_symlink</code>",id:"ensure_file_symlink",children:[]},{value:"<code>ensure_subdirs_exist</code>",id:"ensure_subdirs_exist",children:[]},{value:"<code>feature</code>",id:"feature",children:[]},{value:"<code>genrule_layer</code>",id:"genrule_layer",children:[{value:"Danger! Danger! Danger!",id:"danger-danger-danger",children:[]}]},{value:"<code>group_add</code>",id:"group_add",children:[]},{value:"<code>host_dir_mount</code>",id:"host_dir_mount",children:[]},{value:"<code>host_file_mount</code>",id:"host_file_mount",children:[]},{value:"<code>install</code>",id:"install",children:[]},{value:"<code>install_buck_runnable</code>",id:"install_buck_runnable",children:[{value:"When to use <code>install_buck_runnable</code> vs <code>install</code>?",id:"when-to-use-install_buck_runnable-vs-install",children:[]}]},{value:"<code>layer</code>",id:"layer",children:[]},{value:"<code>layer_alias</code>",id:"layer_alias",children:[]},{value:"<code>layer_mount</code>",id:"layer_mount",children:[]},{value:"<code>package</code>",id:"package",children:[]},{value:"<code>packaged_layer</code>",id:"packaged_layer",children:[]},{value:"<code>python_unittest</code>",id:"python_unittest",children:[]},{value:"<code>remove</code>",id:"remove",children:[]},{value:"<code>rpms_install</code>",id:"rpms_install",children:[]},{value:"<code>rpms_remove_if_exists</code>",id:"rpms_remove_if_exists",children:[]},{value:"<code>sendstream_layer</code>",id:"sendstream_layer",children:[]},{value:"<code>source</code>",id:"source",children:[]},{value:"<code>tarball</code>",id:"tarball",children:[]},{value:"<code>test_rpm_names</code>",id:"test_rpm_names",children:[]},{value:"<code>user_add</code>",id:"user_add",children:[]}],s={toc:b};function c(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"This provides a more friendly UI to the image_* macros."),Object(r.b)("h1",{id:"api"},"API"),Object(r.b)("h2",{id:"clone"},Object(r.b)("inlineCode",{parentName:"h2"},"clone")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"clone(src_layer, src_path, dest_path)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},'image.clone("//path/to:src_layer", "src/path", "dest/path")')," copies a\nsubtree of an existing layer into the one under construction. To the extent\npossible, filesystem metadata are preserved."),Object(r.b)("h3",{id:"trailing-slashes-on-both-paths-are-significant"},"Trailing slashes on both paths are significant"),Object(r.b)("p",null,"The three supported cases are:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},'"s/rc" -> "dest/" creates "dest/rc"'),Object(r.b)("li",{parentName:"ul"},'"s/rc/" -> "dest/" creates "dest/(children of rc)"'),Object(r.b)("li",{parentName:"ul"},'"s/rc" -> "dest" creates "dest"')),Object(r.b)("p",null,"More explicitly:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"A trailing slash in ",Object(r.b)("inlineCode",{parentName:"li"},"src_path"),' means "use the ',Object(r.b)("inlineCode",{parentName:"li"},"rsync"),' convention":',Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"Do not clone the source directory, but only its contents."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"dest_path")," must be a pre-existing dir, and it must end in ",Object(r.b)("inlineCode",{parentName:"li"},"/")))),Object(r.b)("li",{parentName:"ul"},"Similar to ",Object(r.b)("inlineCode",{parentName:"li"},"image.symlink*"),", a trailing slash in ",Object(r.b)("inlineCode",{parentName:"li"},"dest_path")," means that it's a\npre-existing directory (e.g.  made by ",Object(r.b)("inlineCode",{parentName:"li"},"image.ensure_dirs_exist"),"), and\n",Object(r.b)("inlineCode",{parentName:"li"},"clone")," will only write to:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"dest/(basename of src_path)")," if ",Object(r.b)("inlineCode",{parentName:"li"},"src_path")," lacks a trailing /"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"dest/(children of src_path)")," if ",Object(r.b)("inlineCode",{parentName:"li"},"src_path")," has a trailing /")))),Object(r.b)("h3",{id:"known-deviations-from-perfect-cloning"},"Known deviations from perfect cloning"),Object(r.b)("p",null,"Most likely, SELinux attrs change. Future: add real tests for this?"),Object(r.b)("h3",{id:"no-uidgid-remapping-is-attempted"},"No UID/GID remapping is attempted"),Object(r.b)("p",null,"We assume that ",Object(r.b)("inlineCode",{parentName:"p"},":src_layer")," has the same user/group DB as the new layer."),Object(r.b)("h3",{id:"when-to-use-this"},"When to use this?"),Object(r.b)("p",null,"Often, instead of using , you should prefer ",Object(r.b)("inlineCode",{parentName:"p"},"image.layer_mount"),", which allows\nyou to compose independent pieces of the filesystem at ",Object(r.b)("em",{parentName:"p"},"runtime"),", without\nincurring the cost of publishing images with a lot of duplicated content."),Object(r.b)("p",null,"If you're trying to copy the output of a regular Buck target, instead use\n",Object(r.b)("inlineCode",{parentName:"p"},"image.install")," or ",Object(r.b)("inlineCode",{parentName:"p"},"image.install_buck_runnable"),". These rewrite filesystem\nmetadata to a deterministic state, while the state of the on-disk metadata in\n",Object(r.b)("inlineCode",{parentName:"p"},"buck-out")," is undefined."),Object(r.b)("h2",{id:"cpp_unittest"},Object(r.b)("inlineCode",{parentName:"h2"},"cpp_unittest")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"cpp_unittest(name, layer, boot, run_as_user, visibility, hostname, container_opts, **cpp_unittest_kwargs)")),Object(r.b)("p",null,"No docstring available."),Object(r.b)("h2",{id:"rust_unittest"},Object(r.b)("inlineCode",{parentName:"h2"},"rust_unittest")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"rust_unittest(name, layer, boot, run_as_user, hostname, container_opts, visibility, **rust_unittest_kwargs)")),Object(r.b)("p",null,"No docstring available."),Object(r.b)("h2",{id:"ensure_dir_symlink"},Object(r.b)("inlineCode",{parentName:"h2"},"ensure_dir_symlink")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"ensure_dir_symlink(link_target, link_name)")),Object(r.b)("p",null,"The operation follows rsync convention for a destination (",Object(r.b)("inlineCode",{parentName:"p"},"link_name"),"):\n",Object(r.b)("inlineCode",{parentName:"p"},"ends/in/slash/"),' means "write into this directory", ',Object(r.b)("inlineCode",{parentName:"p"},"does/not/end/with/slash"),'\nmeans "write with the specified filename":'),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'image.ensure_dir_symlink("/d", "/e/")')," symlinks directory ",Object(r.b)("inlineCode",{parentName:"li"},"/d")," to ",Object(r.b)("inlineCode",{parentName:"li"},"/e/d")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'image.ensure_dir_symlink("/a", "/b/c")')," symlinks directory ",Object(r.b)("inlineCode",{parentName:"li"},"/a")," to ",Object(r.b)("inlineCode",{parentName:"li"},"/b/c"))),Object(r.b)("p",null,"Both arguments are mandatory:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"link_target")," is the image-absolute source file/dir of the symlink.\nThis file must exist as we do not support dangling symlinks."),Object(r.b)("p",{parentName:"li"},"  IMPORTANT: The emitted symlink will be ",Object(r.b)("strong",{parentName:"p"},"relative")," by default, enabling\neasier inspection if images via ",Object(r.b)("inlineCode",{parentName:"p"},"buck-image-out"),". If this is a problem\nfor you, we can add an ",Object(r.b)("inlineCode",{parentName:"p"},"absolute")," boolean kwarg.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"link_name")," is an image-absolute path. A trailing / is significant."),Object(r.b)("p",{parentName:"li"},"  A ",Object(r.b)("inlineCode",{parentName:"p"},"link_name")," that does NOT end in / is a full path in the new image,\nending with a filename for the new symlink."),Object(r.b)("p",{parentName:"li"},"  As with ",Object(r.b)("inlineCode",{parentName:"p"},"image.clone"),", a traling / means that ",Object(r.b)("inlineCode",{parentName:"p"},"link_name")," must be a\npre-existing directory in the image (e.g. created via\n",Object(r.b)("inlineCode",{parentName:"p"},"image.ensure_dirs_exist"),"), and the actual link will be placed at\n",Object(r.b)("inlineCode",{parentName:"p"},"link_name/(basename of link_target)"),"."))),Object(r.b)("p",null,"This item is indempotent: it is a no-op if a symlink already exists that\nmatches the spec."),Object(r.b)("h2",{id:"ensure_dirs_exist"},Object(r.b)("inlineCode",{parentName:"h2"},"ensure_dirs_exist")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"ensure_dirs_exist(path, mode, user, group)")),Object(r.b)("p",null,"Equivalent to ",Object(r.b)("inlineCode",{parentName:"p"},'image.ensure_subdirs_exist("/", path, ...)'),"."),Object(r.b)("h2",{id:"ensure_file_symlink"},Object(r.b)("inlineCode",{parentName:"h2"},"ensure_file_symlink")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"ensure_file_symlink(link_target, link_name)")),Object(r.b)("p",null,"The operation follows rsync convention for a destination (",Object(r.b)("inlineCode",{parentName:"p"},"link_name"),"):\n",Object(r.b)("inlineCode",{parentName:"p"},"ends/in/slash/"),' means "write into this directory", ',Object(r.b)("inlineCode",{parentName:"p"},"does/not/end/with/slash"),'\nmeans "write with the specified filename":'),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'image.ensure_file_symlink("/d", "/e/")')," symlinks file ",Object(r.b)("inlineCode",{parentName:"li"},"/d")," to ",Object(r.b)("inlineCode",{parentName:"li"},"/e/d")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'image.ensure_file_symlink("/a", "/b/c")')," symlinks file ",Object(r.b)("inlineCode",{parentName:"li"},"/a")," to ",Object(r.b)("inlineCode",{parentName:"li"},"/b/c"))),Object(r.b)("p",null,"Both arguments are mandatory:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"link_target")," is the image-absolute source file/dir of the symlink.\nThis file must exist as we do not support dangling symlinks."),Object(r.b)("p",{parentName:"li"},"  IMPORTANT: The emitted symlink will be ",Object(r.b)("strong",{parentName:"p"},"relative")," by default, enabling\neasier inspection if images via ",Object(r.b)("inlineCode",{parentName:"p"},"buck-image-out"),". If this is a problem\nfor you, we can add an ",Object(r.b)("inlineCode",{parentName:"p"},"absolute")," boolean kwarg.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"link_name")," is an image-absolute path. A trailing / is significant."),Object(r.b)("p",{parentName:"li"},"  A ",Object(r.b)("inlineCode",{parentName:"p"},"link_name")," that does NOT end in / is a full path in the new image,\nending with a filename for the new symlink."),Object(r.b)("p",{parentName:"li"},"  As with ",Object(r.b)("inlineCode",{parentName:"p"},"image.clone"),", a traling / means that ",Object(r.b)("inlineCode",{parentName:"p"},"link_name")," must be a\npre-existing directory in the image (e.g. created via\n",Object(r.b)("inlineCode",{parentName:"p"},"image.ensure_dirs_exist"),"), and the actual link will be placed at\n",Object(r.b)("inlineCode",{parentName:"p"},"link_name/(basename of link_target)"),"."))),Object(r.b)("p",null,"This item is indempotent: it is a no-op if a symlink already exists that\nmatches the spec."),Object(r.b)("h2",{id:"ensure_subdirs_exist"},Object(r.b)("inlineCode",{parentName:"h2"},"ensure_subdirs_exist")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"ensure_subdirs_exist(into_dir, subdirs_to_create, mode, user, group)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},'image.ensure_subdirs_exist("/w/x", "y/z")')," creates the directories ",Object(r.b)("inlineCode",{parentName:"p"},"/w/x/y"),"\nand ",Object(r.b)("inlineCode",{parentName:"p"},"/w/x/y/z")," in the image, if they do not exist. ",Object(r.b)("inlineCode",{parentName:"p"},"/w/x")," must have already\nbeen created by another image feature. If any dirs to be created already exist\nin the image, their attributes will be checked to ensure they match the\nattributes provided here. If any do not match, the build will fail."),Object(r.b)("p",null,"The arguments ",Object(r.b)("inlineCode",{parentName:"p"},"into_dir")," and ",Object(r.b)("inlineCode",{parentName:"p"},"subdirs_to_create")," are mandatory; ",Object(r.b)("inlineCode",{parentName:"p"},"mode"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"user"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"group")," are optional."),Object(r.b)("p",null,"The argument ",Object(r.b)("inlineCode",{parentName:"p"},"mode")," changes file mode bits of all directories in\n",Object(r.b)("inlineCode",{parentName:"p"},"subdirs_to_create"),". It can be an integer fully specifying the bits or a\nsymbolic string like ",Object(r.b)("inlineCode",{parentName:"p"},"u+rx"),". In the latter case, the changes are applied on\ntop of mode 0."),Object(r.b)("p",null,"The arguments ",Object(r.b)("inlineCode",{parentName:"p"},"user")," and ",Object(r.b)("inlineCode",{parentName:"p"},"group")," change file owner and group of all\ndirectories in ",Object(r.b)("inlineCode",{parentName:"p"},"subdirs_to_create"),". ",Object(r.b)("inlineCode",{parentName:"p"},"user")," and ",Object(r.b)("inlineCode",{parentName:"p"},"group")," can be integers or\nsymbolic strings. In the latter case, the passwd/group database from the host\n(not from the image) is used."),Object(r.b)("h2",{id:"feature"},Object(r.b)("inlineCode",{parentName:"h2"},"feature")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"feature(name, features, visibility, flavors)")),Object(r.b)("p",null,"No docstring available."),Object(r.b)("h2",{id:"genrule_layer"},Object(r.b)("inlineCode",{parentName:"h2"},"genrule_layer")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"genrule_layer(name, rule_type, cmd, user, parent_layer, flavor, flavor_config_override, container_opts, **image_layer_kwargs)")),Object(r.b)("h3",{id:"danger-danger-danger"},"Danger! Danger! Danger!"),Object(r.b)("p",null,"The resulting layer captures the result of executing a command inside\nanother ",Object(r.b)("inlineCode",{parentName:"p"},"image.layer"),".  This is a power tool intended for extending Antlir\nwith new macros.  It must be used with ",Object(r.b)("em",{parentName:"p"},"extreme caution"),".  Please\n",Object(r.b)("strong",{parentName:"p"},"carefully read ",Object(r.b)("a",Object(a.a)({parentName:"strong"},{href:"/docs/genrule-layer"}),"the full docs"))," before using."),Object(r.b)("p",null,"Mandatory arguments:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cmd"),": The command to execute inside the layer.  See the ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/genrule-layer"}),"full\ndocs")," for details on the constraints.  ",Object(r.b)("strong",{parentName:"li"},"PLEASE\nKEEP THIS DETERMINISTIC.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"rule_type"),": The resulting Buck target node will have type\n",Object(r.b)("inlineCode",{parentName:"li"},"image_genrule_layer_{rule_type}"),", which allows ",Object(r.b)("inlineCode",{parentName:"li"},"buck query"),"ing for this\nspecific kind of genrule layer.  Required because the intended usage for\ngenrule layers is the creation of new macros, and type-tagging lets\nAntlir maintainers survey this ecosystem without resorting to ",Object(r.b)("inlineCode",{parentName:"li"},"grep"),".")),Object(r.b)("p",null,"Optional arguments:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"user")," (defaults to ",Object(r.b)("inlineCode",{parentName:"li"},"nobody"),"): Run ",Object(r.b)("inlineCode",{parentName:"li"},"cmd")," as this user inside the image."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"parent_layer"),": The name of another layer target, inside of which\n",Object(r.b)("inlineCode",{parentName:"li"},"cmd")," will be executed."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"flavor"),": The build flavor that will be used to load the config from\nREPO_CFG.flavor_to_config"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"flavor_config_overrde"),": A struct that contains fields that override\nthe default values specific by ",Object(r.b)("inlineCode",{parentName:"li"},"flavor"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"container_opts"),": An ",Object(r.b)("inlineCode",{parentName:"li"},"image.opts")," containing keys from ",Object(r.b)("inlineCode",{parentName:"li"},"container_opts_t"),".\nIf you want to install packages, you will usually want to set\n",Object(r.b)("inlineCode",{parentName:"li"},"shadow_proxied_binaries")," here."),Object(r.b)("li",{parentName:"ul"},"See the ",Object(r.b)("inlineCode",{parentName:"li"},"_image_layer_impl")," signature (in ",Object(r.b)("inlineCode",{parentName:"li"},"image_layer_utils.bzl"),")\nfor supported, but less commonly used, kwargs.")),Object(r.b)("h2",{id:"group_add"},Object(r.b)("inlineCode",{parentName:"h2"},"group_add")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"group_add(groupname, gid)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},'image.group_add("leet")')," adds a group ",Object(r.b)("inlineCode",{parentName:"p"},"leet")," with an auto-assigned group ID.\n",Object(r.b)("inlineCode",{parentName:"p"},'image.group_add("leet", 1337)')," adds a group ",Object(r.b)("inlineCode",{parentName:"p"},"leet")," with GID 1337."),Object(r.b)("p",null,"Group add semantics generally follow ",Object(r.b)("inlineCode",{parentName:"p"},"groupadd"),". If groupname or GID conflicts\nwith existing entries, image build will fail. It is recommended to avoid\nspecifying GID unless absolutely necessary."),Object(r.b)("p",null,"It is also recommended to always reference groupnames and not GIDs; since GIDs\nare auto-assigned, they may change if underlying layers add/remove groups."),Object(r.b)("h2",{id:"host_dir_mount"},Object(r.b)("inlineCode",{parentName:"h2"},"host_dir_mount")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"host_dir_mount(source, mountpoint)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},'image.host_dir_mount("/path/foo")')," bind-mounts the host directory\n",Object(r.b)("inlineCode",{parentName:"p"},"/path/foo")," into the container at ",Object(r.b)("inlineCode",{parentName:"p"},"/path/foo"),". Another image item must\nprovide the parent ",Object(r.b)("inlineCode",{parentName:"p"},"/path"),", but this item will create the mount-point."),Object(r.b)("h2",{id:"host_file_mount"},Object(r.b)("inlineCode",{parentName:"h2"},"host_file_mount")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"host_file_mount(source, mountpoint)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},'image.host_file_mount("/path/bar", "/baz")')," bind-mounts the file ",Object(r.b)("inlineCode",{parentName:"p"},"/path/bar"),"\ninto the container at ",Object(r.b)("inlineCode",{parentName:"p"},"/baz"),"."),Object(r.b)("h2",{id:"install"},Object(r.b)("inlineCode",{parentName:"h2"},"install")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"install(source, dest, mode, user, group)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},'image.install("//path/fs:data", "dir/bar")')," installs file or directory\n",Object(r.b)("inlineCode",{parentName:"p"},"data")," to ",Object(r.b)("inlineCode",{parentName:"p"},"dir/bar")," in the image. ",Object(r.b)("inlineCode",{parentName:"p"},"dir/bar")," must not exist, otherwise\nthe operation fails."),Object(r.b)("p",null,"The arguments ",Object(r.b)("inlineCode",{parentName:"p"},"source")," and ",Object(r.b)("inlineCode",{parentName:"p"},"dest")," are mandatory; ",Object(r.b)("inlineCode",{parentName:"p"},"mode"),", ",Object(r.b)("inlineCode",{parentName:"p"},"user"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"group")," are\noptional."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"source")," is either a regular file or a directory. If it is a directory, it must\ncontain only regular files and directories (recursively)."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"mode")," can be used only if ",Object(r.b)("inlineCode",{parentName:"p"},"source")," is a regular file."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"If set, it changes file mode bits of ",Object(r.b)("inlineCode",{parentName:"li"},"dest")," (after installation of ",Object(r.b)("inlineCode",{parentName:"li"},"source"),"\nto ",Object(r.b)("inlineCode",{parentName:"li"},"dest"),"). ",Object(r.b)("inlineCode",{parentName:"li"},"mode")," can be an integer fully specifying the bits or a symbolic\nstring like ",Object(r.b)("inlineCode",{parentName:"li"},"u+rx"),". In the latter case, the changes are applied on top of\nmode 0."),Object(r.b)("li",{parentName:"ul"},"If not set, the mode of ",Object(r.b)("inlineCode",{parentName:"li"},"source")," is ignored, and instead the mode of ",Object(r.b)("inlineCode",{parentName:"li"},"dest"),"\n(and all files and directories inside the ",Object(r.b)("inlineCode",{parentName:"li"},"dest"),' if it is a directory) is set\naccording to the following rule: "u+rwx,og+rx" for directories, "a+rx" for files\nexecutable by the Buck repo user, "a+r" for other files.')),Object(r.b)("p",null,"The arguments ",Object(r.b)("inlineCode",{parentName:"p"},"user")," and ",Object(r.b)("inlineCode",{parentName:"p"},"group")," change file owner and group of all\ndirectories in ",Object(r.b)("inlineCode",{parentName:"p"},"dest"),". ",Object(r.b)("inlineCode",{parentName:"p"},"user")," and ",Object(r.b)("inlineCode",{parentName:"p"},"group")," can be integers or symbolic strings.\nIn the latter case, the passwd/group database from the host (not from the\nimage) is used. The default for ",Object(r.b)("inlineCode",{parentName:"p"},"user")," and ",Object(r.b)("inlineCode",{parentName:"p"},"group")," is ",Object(r.b)("inlineCode",{parentName:"p"},"root"),"."),Object(r.b)("h2",{id:"install_buck_runnable"},Object(r.b)("inlineCode",{parentName:"h2"},"install_buck_runnable")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"install_buck_runnable(source, dest, mode, user, group)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},'image.install_buck_runnable("//path/fs:exe", "dir/foo")')," copies\nbuck-runnable artifact ",Object(r.b)("inlineCode",{parentName:"p"},"exe")," to ",Object(r.b)("inlineCode",{parentName:"p"},"dir/foo")," in the image. Unlike ",Object(r.b)("inlineCode",{parentName:"p"},"install"),",\nthis supports only single files -- though you can extract a file from a\nbuck-runnable directory via ",Object(r.b)("inlineCode",{parentName:"p"},"image.source"),", see below."),Object(r.b)("p",null,"See ",Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"install"))," for documentation on arguments ",Object(r.b)("inlineCode",{parentName:"p"},"mode"),", ",Object(r.b)("inlineCode",{parentName:"p"},"user"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"group"),"."),Object(r.b)("h3",{id:"when-to-use-install_buck_runnable-vs-install"},"When to use ",Object(r.b)("inlineCode",{parentName:"h3"},"install_buck_runnable")," vs ",Object(r.b)("inlineCode",{parentName:"h3"},"install"),"?"),Object(r.b)("p",null,"If the file being copied is a buck-runnable (e.g. ",Object(r.b)("inlineCode",{parentName:"p"},"cpp_binary"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"python_binary"),"), use ",Object(r.b)("inlineCode",{parentName:"p"},"install_buck_runnable"),". Ditto for copying executable\nfiles from inside directories output by buck-runnable rules. For everything\nelse, use ",Object(r.b)("inlineCode",{parentName:"p"},"install")," ","[1]","."),Object(r.b)("p",null,"Important: failing to use ",Object(r.b)("inlineCode",{parentName:"p"},"install_buck_runnable")," will cause the installed\nbinary to be unusable in image tests in @mode/dev."),Object(r.b)("h2",{id:"layer"},Object(r.b)("inlineCode",{parentName:"h2"},"layer")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"layer(name, parent_layer, features, flavor, flavor_config_override, antlir_rule, **image_layer_kwargs)")),Object(r.b)("p",null,"No docstring available."),Object(r.b)("h2",{id:"layer_alias"},Object(r.b)("inlineCode",{parentName:"h2"},"layer_alias")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"layer_alias(name, layer, visibility)")),Object(r.b)("p",null,"No docstring available."),Object(r.b)("h2",{id:"layer_mount"},Object(r.b)("inlineCode",{parentName:"h2"},"layer_mount")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"layer_mount(source, mountpoint)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},'image.layer_mount(":other-image-layer")'),' makes the specified layer available\ninside the container available at the "default_mountpoint" provided by the\nlayer in its config. That fails if the layer lacks a default mountpoint, but\nthen you can pass an explicit ',Object(r.b)("inlineCode",{parentName:"p"},"mountpoint")," argument."),Object(r.b)("h2",{id:"package"},Object(r.b)("inlineCode",{parentName:"h2"},"package")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"package(name, layer, visibility, writable_subvolume, seed_device, antlir_rule, build_appliance, format, size_mb, label)")),Object(r.b)("p",null,"No docstring available."),Object(r.b)("h2",{id:"packaged_layer"},Object(r.b)("inlineCode",{parentName:"h2"},"packaged_layer")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"packaged_layer(layer_name, publisher_name)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"image.packaged_layer")," is a small wrapper around ",Object(r.b)("inlineCode",{parentName:"p"},"image.layer")," to support both\ncreating a layer and including a reference to a corresponding 'publisher' target\nwithin that layer, which is then responsible for publishing that layer as a\nsquashfs package to an external artifact store."),Object(r.b)("p",null,"Args:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"layer_name: Target name that will be given to `partial_layer`.\n\npublisher_name: Target name that will be given to `partial_publisher`.\n\npartial_layer: A partial `image.layer` object that will be supplied with a\n    custom `mount_config` and located under `name`.\n\npartial_publisher: A partial target supporting a `path_actions` argument,\n    which will be provided by the implementation. When run, this target\n    should publish the targets in `path_actions` to an artifact store.\n")),Object(r.b)("h2",{id:"python_unittest"},Object(r.b)("inlineCode",{parentName:"h2"},"python_unittest")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"python_unittest(name, layer, boot, run_as_user, visibility, par_style, hostname, container_opts, **python_unittest_kwargs)")),Object(r.b)("p",null,"No docstring available."),Object(r.b)("h2",{id:"remove"},Object(r.b)("inlineCode",{parentName:"h2"},"remove")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"remove(dest, must_exist)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},'image.remove("/a/b")')," recursively removes the file or directory ",Object(r.b)("inlineCode",{parentName:"p"},"/a/b")," --"),Object(r.b)("p",null,"These are allowed to remove paths inherited from the parent layer, or those\ninstalled by RPMs even in this layer. However, removing other items\nexplicitly added by the current layer is not allowed since that seems like a\ndesign smell -- you should probably refactor the constituent image features\nnot to conflict with each other."),Object(r.b)("p",null,"By default, it is an error if the specified path is missing from the image,\nthough this can be avoided by setting ",Object(r.b)("inlineCode",{parentName:"p"},"must_exist")," to ",Object(r.b)("inlineCode",{parentName:"p"},"False"),"."),Object(r.b)("h2",{id:"rpms_install"},Object(r.b)("inlineCode",{parentName:"h2"},"rpms_install")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"rpms_install(rpmlist)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},'image.rpms_install(["foo"])')," installs ",Object(r.b)("inlineCode",{parentName:"p"},"foo.rpm"),",\n",Object(r.b)("inlineCode",{parentName:"p"},'image.rpms_install(["//target:bar"])')," builds ",Object(r.b)("inlineCode",{parentName:"p"},"bar")," target and installs\nresulting RPM."),Object(r.b)("p",null,"The argument to both functions is a list of RPM package names to install,\nwithout version or release numbers. Dependencies are installed as needed.\nOrder is not significant."),Object(r.b)("p",null,"As shown in the above example, RPMs may also be installed that are the\noutputs of another buck rule by providing a target path or an ",Object(r.b)("inlineCode",{parentName:"p"},"image.source"),"\n(docs in",Object(r.b)("inlineCode",{parentName:"p"},"image_source.bzl"),"), or by directly providing a target path."),Object(r.b)("p",null,"If RPMs are specified by name, as in the first example above, the default\nbehavior is to install the latest available version of the RPMs. Particular\nversions of RPMs can be pinned by specifying ",Object(r.b)("inlineCode",{parentName:"p"},"image.opts")," with\n",Object(r.b)("inlineCode",{parentName:"p"},"rpm_version_set_overrides")," argument. This argument must be the list of\nstructures defined by ",Object(r.b)("inlineCode",{parentName:"p"},"image.rpm.nevra()"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'image.layer(\n    name = "my_layer",\n    features = [\n        image.rpms_install([\n            "foo",\n        ]),\n    ],\n    flavor_config_override = image.opts(\n        rpm_version_set_overrides = [\n            image.rpm.nevra(\n                name = "foo",\n                epoch = "0",\n                version = "1",\n                release = "el7",\n                arch = "x86_64"\n            ),\n        ],\n    ),\n)\n')),Object(r.b)("p",null,"In this example ",Object(r.b)("inlineCode",{parentName:"p"},"foo-1-el7.x86_64")," will be installed into the layer ",Object(r.b)("inlineCode",{parentName:"p"},"my_layer"),"\neven if a newer version is available."),Object(r.b)("p",null,"If the argument ",Object(r.b)("inlineCode",{parentName:"p"},"rpmlist")," lists both RPM name and buck rule targets, RPMs\nspecified by buck rule targets are installed before RPMs specified by names.\nHence, if an RPM defined by name requires a newer version of an RPM defined by\nbuck rule target, the RPM will be upgraded and the whole operation may succeed.\nThus, the explicit specification of RPM version by buck rule does not guarantee\nthat this particular version is present in resulting image."),Object(r.b)("p",null,"Another important caveat about RPMs specified by buck rule targets is that\ndowngrade is allowable: if the parent layer has RPM ",Object(r.b)("inlineCode",{parentName:"p"},"foobar-v2")," installed, and\nthen ",Object(r.b)("inlineCode",{parentName:"p"},"foobar-v1")," is specified by a buck rule, the result of RPM installation\nwill be ",Object(r.b)("inlineCode",{parentName:"p"},"foobar-v2")," downgraded to ",Object(r.b)("inlineCode",{parentName:"p"},"foobar-v1"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"image.rpms_install()")," provides only limited support for RPM post-install\nscripts. Those scripts are executed in a virtual environment without runtime\nmounts like ",Object(r.b)("inlineCode",{parentName:"p"},"/proc"),". As an example, the script may invoke a binary requiring\n",Object(r.b)("inlineCode",{parentName:"p"},"/proc/self/exe")," or a shared library from a directory not available in the\nimage. Then the binary fails, and the final result of the operation would differ\nfrom the RPM installation on the host where the binary succeeds. The issue may\nbe aggravated by the lack of error handling in the script making the RPM install\noperation successful even if the binary fails."),Object(r.b)("h2",{id:"rpms_remove_if_exists"},Object(r.b)("inlineCode",{parentName:"h2"},"rpms_remove_if_exists")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"rpms_remove_if_exists(rpmlist)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},'image.rpms_remove_if_exists(["baz"])')," removes ",Object(r.b)("inlineCode",{parentName:"p"},"baz.rpm")," if exists."),Object(r.b)("p",null,"Note that removals may only be applied against the parent layer -- if your\ncurrent layer includes features both removing and installing the same\npackage, this will cause a build failure."),Object(r.b)("h2",{id:"sendstream_layer"},Object(r.b)("inlineCode",{parentName:"h2"},"sendstream_layer")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"sendstream_layer(name, source, flavor, flavor_config_override, antlir_rule, subvol_name, **image_layer_kwargs)")),Object(r.b)("p",null,"No docstring available."),Object(r.b)("h2",{id:"source"},Object(r.b)("inlineCode",{parentName:"h2"},"source")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"source(source, **kwargs)")),Object(r.b)("p",null,"No docstring available."),Object(r.b)("h2",{id:"tarball"},Object(r.b)("inlineCode",{parentName:"h2"},"tarball")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"tarball(source, dest, force_root_ownership)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},'image.tarball("files/xyz.tar", "/a/b")')," extracts tarball located at ",Object(r.b)("inlineCode",{parentName:"p"},"files/xyz.tar")," to ",Object(r.b)("inlineCode",{parentName:"p"},"/a/b")," in the image --"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"source")," is one of:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"an ",Object(r.b)("inlineCode",{parentName:"li"},"image.source")," (docs in ",Object(r.b)("inlineCode",{parentName:"li"},"image_source.bzl"),"), or"),Object(r.b)("li",{parentName:"ul"},"the path of a target outputting a tarball target path,\ne.g. an ",Object(r.b)("inlineCode",{parentName:"li"},"export_file")," or a ",Object(r.b)("inlineCode",{parentName:"li"},"genrule")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"dest")," is the destination of the unpacked tarball in the image.\nThis is an image-absolute path to a directory that must be created\nby another ",Object(r.b)("inlineCode",{parentName:"li"},"image_feature")," item.\n")),Object(r.b)("h2",{id:"test_rpm_names"},Object(r.b)("inlineCode",{parentName:"h2"},"test_rpm_names")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"test_rpm_names(name, layer, rpm_list)")),Object(r.b)("p",null,"No docstring available."),Object(r.b)("h2",{id:"user_add"},Object(r.b)("inlineCode",{parentName:"h2"},"user_add")),Object(r.b)("p",null,"Prototype: ",Object(r.b)("inlineCode",{parentName:"p"},"user_add(username, primary_group, home_dir, shell, uid, supplementary_groups, comment)")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"image.user_add")," adds a user entry to /etc/passwd."),Object(r.b)("p",null,"Example usage:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'image.group_add("myuser")\nimage.user_add(\n    "myuser",\n    primary_group = "myuser",\n    home_dir = "/home/myuser",\n)\nimage.ensure_dirs_exist(\n    "/home/myuser",\n    mode = 0o755,\n    user = "myuser",\n    group = "myuser",\n)\n')),Object(r.b)("p",null,"Unlike shadow-utils ",Object(r.b)("inlineCode",{parentName:"p"},"useradd"),", this item does not automatically create the new\nuser's initial login group or home directory."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"If ",Object(r.b)("inlineCode",{parentName:"li"},"username")," or ",Object(r.b)("inlineCode",{parentName:"li"},"uid")," conflicts with existing entries, image build will\nfail. It is recommended to avoid specifying UID unless absolutely\nnecessary."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"primary_group")," and ",Object(r.b)("inlineCode",{parentName:"li"},"supplementary_groups")," are specified as groupnames."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"home_dir")," should exist, but this item does not ensure/depend on it to avoid\na circular dependency on directory's owner user.\n")))}c.isMDXComponent=!0}}]);