(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{103:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return u}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),b=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=b(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=b(n),m=a,u=p["".concat(r,".").concat(m)]||p[m]||d[m]||o;return n?i.a.createElement(u,l(l({ref:t},c),{},{components:n})):i.a.createElement(u,l({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},96:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return b}));var a=n(3),i=n(7),o=(n(0),n(103)),r={id:"python",title:"Python"},l={unversionedId:"contributing/coding-conventions/python",id:"contributing/coding-conventions/python",isDocsHomePage:!1,title:"Python",description:"The codebase has legacy files, please send diffs to fix them",source:"@site/docs/contributing/coding-conventions/python.md",slug:"/contributing/coding-conventions/python",permalink:"/antlir/docs/contributing/coding-conventions/python",editUrl:"https://github.com/facebookincubator/antlir/edit/master/website/docs/contributing/coding-conventions/python.md",version:"current",sidebar:"docs",previous:{title:"Pyre",permalink:"/antlir/docs/contributing/coding-conventions/pyre"},next:{title:"btrfs_diff/",permalink:"/antlir/docs/contributing/todos/btrfs_diff"}},s=[{value:"The codebase has legacy files, please send diffs to fix them",id:"the-codebase-has-legacy-files-please-send-diffs-to-fix-them",children:[]},{value:"Stay lint clean",id:"stay-lint-clean",children:[]},{value:"Testing",id:"testing",children:[{value:"All code should enforce 100% test coverage",id:"all-code-should-enforce-100-test-coverage",children:[]},{value:"Avoid <code>unittest.mock</code> when possible",id:"avoid-unittestmock-when-possible",children:[]}]},{value:"<code>TARGETS</code>, resources &amp; imports",id:"targets-resources--imports",children:[{value:"Avoid <code>base_module</code>, prefer absolute imports (with exceptions)",id:"avoid-base_module-prefer-absolute-imports-with-exceptions",children:[]},{value:"Use <code>Path.resource</code> and <code>layer_resource_subvol</code>; avoid <code>__file__</code>, <code>importlib.resources.path</code>",id:"use-pathresource-and-layer_resource_subvol-avoid-__file__-importlibresourcespath",children:[]},{value:"Import ordering",id:"import-ordering",children:[]}]},{value:"General",id:"general",children:[{value:"Recommended <code>__main__</code> boilerplate",id:"recommended-__main__-boilerplate",children:[]},{value:"Logging",id:"logging",children:[]},{value:"Formatting: PEP-8, 80 chars",id:"formatting-pep-8-80-chars",children:[]},{value:"Use <code>Path</code> from <code>antlir.fs_utils</code>, avoid <code>pathlib</code>",id:"use-path-from-antlirfs_utils-avoid-pathlib",children:[]},{value:"Use context managers instead of functions when appropriate",id:"use-context-managers-instead-of-functions-when-appropriate",children:[]},{value:"Prefer long-form args (<code>--absolute-names</code>) over short (<code>-P</code>)",id:"prefer-long-form-args---absolute-names-over-short--p",children:[]},{value:"Use the <code>--foo=bar</code> form for long-form args when possible",id:"use-the---foobar-form-for-long-form-args-when-possible",children:[]},{value:"Respect private identifiers",id:"respect-private-identifiers",children:[]},{value:"Limit positional args to 2, use keyword-only args (<code>pos, *, kw1, kw2</code>)",id:"limit-positional-args-to-2-use-keyword-only-args-pos--kw1-kw2",children:[]}]}],c={toc:s};function b(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h3",{id:"the-codebase-has-legacy-files-please-send-diffs-to-fix-them"},"The codebase has legacy files, please send diffs to fix them"),Object(o.b)("p",null,"But, also, please do not mix no-op refactors with business logic changes. Plan\nahead, or use ",Object(o.b)("inlineCode",{parentName:"p"},"hg split"),"."),Object(o.b)("h3",{id:"stay-lint-clean"},"Stay lint clean"),Object(o.b)("p",null,"If a linter rule is causing you problems, let's talk about fixing the lint rule\ninstead."),Object(o.b)("h2",{id:"testing"},"Testing"),Object(o.b)("h3",{id:"all-code-should-enforce-100-test-coverage"},"All code should enforce 100% test coverage"),Object(o.b)("p",null,"This is Python. If code wasn't executed, it's definitely wrong (incompatible\ntypes, bad kwargs, etc). Once we fully adopt Pyre, it'll help catch some shallow\nbugs before you write tests, but the coverage requirement ought to remain."),Object(o.b)("p",null,"Of course, you should aspire to actually break your code by thinking about what\nit does, what can go wrong, and how to best exercise it. 100% line coverage is\njust the bare minimum."),Object(o.b)("p",null,"Specifically, Python library and binary targets should be mentioned in a test\nlike so:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),'needed_coverage = [\n    (":library_name", 100),\n    (":binary-name-library", 100),  # `python_binary` defines an implicit `-library` target\n]\n')),Object(o.b)("p",null,"There are scant exceptions to this, which justify the usage of ",Object(o.b)("inlineCode",{parentName:"p"},"# pragma: no\ncover")," on a line or block level:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Tests can't assert coverage below ",Object(o.b)("inlineCode",{parentName:"li"},"if __name__ == '__main__'"),". Try to keep\nthat block minimal, and to export most logic to a ",Object(o.b)("inlineCode",{parentName:"li"},"main()")," function. Also,\nmention above ",Object(o.b)("inlineCode",{parentName:"li"},"__main__")," the integration test that covers this code path (or\nthat this code path is for human debugging only, in which case a manual smoke\ntest is appreciated)."),Object(o.b)("li",{parentName:"ul"},"If you have an error check that's essentially an assertion, then you can ",Object(o.b)("inlineCode",{parentName:"li"},"#\npragma: no cover")," it. Note that using ",Object(o.b)("inlineCode",{parentName:"li"},"assert")," instead of ",Object(o.b)("inlineCode",{parentName:"li"},"if foo: raise")," has\nessentially the same effect. Be judicious about error cases that are left\nuncovered --consider at least these risks:",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"bad:")," we don't generate an error, or generate the wrong kind of\nerror, and the program will continue normally when it should have\nfailed,"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"not great:")," the untested error message makes it hard to debug a real\nfailure -- e.g. you forgot the ",Object(o.b)("inlineCode",{parentName:"li"},"f")," in front of an f-string.")))),Object(o.b)("h3",{id:"avoid-unittestmock-when-possible"},"Avoid ",Object(o.b)("inlineCode",{parentName:"h3"},"unittest.mock")," when possible"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"To unit-test ",Object(o.b)("inlineCode",{parentName:"li"},"antlir")," code, design testable interfaces from day 1."),Object(o.b)("li",{parentName:"ul"},"Also design code to permit bottom-up easy integration tests -- these are\nworth far more than mock tests."),Object(o.b)("li",{parentName:"ul"},"When it's necessary to cut out a dependency from a test (because it's heavy,\nunreliable, or otherwise inaccessble to tests), prefer to ",Object(o.b)("strong",{parentName:"li"},"fake")," it\ninstead of mocking it. This entails configuring your code to point at a\ndependency that quacks like the one you expect, but is acceptable in tests.\nThe main distinction from, and advantage over, mocks is that this tests the\ncomplete interaction you expect with the external system, instead of making\nsparse assertions about, the way a mock might. Note that in some cases,\nusing ",Object(o.b)("inlineCode",{parentName:"li"},"unittest.mock")," to inject fakes is fine."),Object(o.b)("li",{parentName:"ul"},"When interfacing with external, unreliable, and hard-to-fake subsystems, it\nis acceptable to do mock tests."),Object(o.b)("li",{parentName:"ul"},"When using ",Object(o.b)("inlineCode",{parentName:"li"},"unittest.mock"),", watch out for over-generic mocks, which end up\nbeing fragile. I.e. instead of mocking ",Object(o.b)("inlineCode",{parentName:"li"},"subprocess.check_output"),", consider\ndefining ",Object(o.b)("inlineCode",{parentName:"li"},"_run_my_subprog = subprocess.check_output")," in your module, and\nmocking ",Object(o.b)("inlineCode",{parentName:"li"},"_run_my_subprog"),".")),Object(o.b)("h2",{id:"targets-resources--imports"},Object(o.b)("inlineCode",{parentName:"h2"},"TARGETS"),", resources & imports"),Object(o.b)("h3",{id:"avoid-base_module-prefer-absolute-imports-with-exceptions"},"Avoid ",Object(o.b)("inlineCode",{parentName:"h3"},"base_module"),", prefer absolute imports (with exceptions)"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Please work to eliminate ",Object(o.b)("inlineCode",{parentName:"li"},"base_module")," from ",Object(o.b)("inlineCode",{parentName:"li"},"TARGETS")," files. This is\ndeprecated throughout Facebook, and generally complicates code\ncomprehension. In other words, your module in ",Object(o.b)("inlineCode",{parentName:"li"},"fbcode/antlir/foo.py"),"\nshould be importable as ",Object(o.b)("inlineCode",{parentName:"li"},"antlir.foo"),"."),Object(o.b)("li",{parentName:"ul"},"Use absolute imports. Two exceptions are OK:",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Access sibling libraries: ",Object(o.b)("inlineCode",{parentName:"li"},"from . import sibling_module")),Object(o.b)("li",{parentName:"ul"},"Access parent from tests: ",Object(o.b)("inlineCode",{parentName:"li"},"from .. import module_being_tested"),".")))),Object(o.b)("h3",{id:"use-pathresource-and-layer_resource_subvol-avoid-__file__-importlibresourcespath"},"Use ",Object(o.b)("inlineCode",{parentName:"h3"},"Path.resource")," and ",Object(o.b)("inlineCode",{parentName:"h3"},"layer_resource_subvol"),"; avoid ",Object(o.b)("inlineCode",{parentName:"h3"},"__file__"),", ",Object(o.b)("inlineCode",{parentName:"h3"},"importlib.resources.path")),Object(o.b)("p",null,"Your ",Object(o.b)("inlineCode",{parentName:"p"},"python_unittest")," or ",Object(o.b)("inlineCode",{parentName:"p"},"python_binary")," has ",Object(o.b)("inlineCode",{parentName:"p"},"resources"),". You want to access\nthe files from the running code. In ",Object(o.b)("inlineCode",{parentName:"p"},"@mode/dev"),", most of the above will kind of\nwork. However, in ",Object(o.b)("inlineCode",{parentName:"p"},"@mode/opt")," and open-source, it's hard to get it right. Our\npath towards fixing this disaster is as follows:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Step 1: Standardize on ",Object(o.b)("inlineCode",{parentName:"li"},"with Path.resource(__package__, 'path')")),Object(o.b)("li",{parentName:"ul"},"Step 2: Make that context manager work correctly in all settings.")),Object(o.b)("h4",{id:"rationale"},"Rationale"),Object(o.b)("p",null,"Our Python code runs in ","~","3 settings:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"@mode/dev"),": This is an in-place linktree, so ",Object(o.b)("inlineCode",{parentName:"li"},"__file__")," and ",Object(o.b)("inlineCode",{parentName:"li"},"importlib"),"\nwork."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"@mode/opt")," with ",Object(o.b)("inlineCode",{parentName:"li"},'par_style = "fastzip"')," (roughly equivalent to OSS PEX):\nNeither ",Object(o.b)("inlineCode",{parentName:"li"},"__file__")," and ",Object(o.b)("inlineCode",{parentName:"li"},"importlib")," work."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"@mode/opt")," with ",Object(o.b)("inlineCode",{parentName:"li"},'par_style = "xar"'),": In this mode, both ",Object(o.b)("inlineCode",{parentName:"li"},"__file__")," and\n",Object(o.b)("inlineCode",{parentName:"li"},"importlib")," work, but it's hard to reproduce in OSS. Historically, when we\nfound ",Object(o.b)("inlineCode",{parentName:"li"},"@mode/opt")," issues, we would paper over them by converting certain\nbinaries as XARs (which, incidentally, do not compose well with ",Object(o.b)("inlineCode",{parentName:"li"},"sudo"),").\nHaving these overrides is an ongoing cost to developers we have to keep in\nmind all of these constraints, and we often get it wrong and break\n",Object(o.b)("inlineCode",{parentName:"li"},"@mode/opt"),".")),Object(o.b)("p",null,"For these reasons, we are standardizing on ",Object(o.b)("inlineCode",{parentName:"p"},"Path.resource")," to the exclusion of\neverything else."),Object(o.b)("h4",{id:"why-are-target_location--load_location-deprecated"},"Why are ",Object(o.b)("inlineCode",{parentName:"h4"},"target_location")," / ",Object(o.b)("inlineCode",{parentName:"h4"},"load_location")," deprecated?"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"target_location")," cannot work properly with distributed Buck caches. If your\nbinary is built on Sandcastle trunk, it will have embedded inside an absolute\npath to a resource that is only valid in that Sandcastle container (or at any\nrate, in similar Sandcastle containers). Therefore, this binary will fail to run\nanywhere else, including devboxes. We haven't seen much of this because it only\naffects ",Object(o.b)("inlineCode",{parentName:"p"},"@mode/opt")," runs not on Sandcastle, and our usage is low."),Object(o.b)("h3",{id:"import-ordering"},"Import ordering"),Object(o.b)("p",null,'We recommend sectioned imports, separated by a single blank line. First come\nstandard modules, then "other" fs',"_","image modules, last come sibling submodules\nor modules under test. Only the last section may use relative imports. Each\nsection splits into 2 subsections: first all ",Object(o.b)("inlineCode",{parentName:"p"},"import x"),", then ",Object(o.b)("inlineCode",{parentName:"p"},"from y import z"),".\nExample:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"import standard_module\n\nfrom other_standard import std_name\n\nfrom antlir.foo import bar\n\n# In a submodule\nfrom .sibling_submodule import _impl_detail\n\n# In a test\nfrom ..module_being_tested import func_to_test\n")),Object(o.b)("h2",{id:"general"},"General"),Object(o.b)("h3",{id:"recommended-__main__-boilerplate"},"Recommended ",Object(o.b)("inlineCode",{parentName:"h3"},"__main__")," boilerplate"),Object(o.b)("p",null,"A main function of any complexity should be a separate function and covered by\nunit tests. Any main (simple or not) should be covered by ",Object(o.b)("em",{parentName:"p"},"some")," (not\nnecessarily dedicated) integration test, unless it can only invoked by\n",Object(o.b)("inlineCode",{parentName:"p"},"antlir")," developers for debugging."),Object(o.b)("p",null,"A typical main should use ",Object(o.b)("inlineCode",{parentName:"p"},"init_cli")," to set up logging & argparse:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"if __name__ == '__main__':\n    from antlir.cli import init_cli\n\n    with init_cli(__doc__) as cli:\n        cli.parser.add_argument(\"--your-arg\")\n\n    business_logic(cli.args)\n")),Object(o.b)("p",null,'In a "simple" main that has ample integration test coverage, it is OK to\ncompose a few business logic functions inline, as long as you do no\nbranching.  ',Object(o.b)("strong",{parentName:"p"},"If in doubt, use a separate main function and write\nunit-tests.")),Object(o.b)("h3",{id:"logging"},"Logging"),Object(o.b)("p",null,"It's the responsibility of any ",Object(o.b)("inlineCode",{parentName:"p"},"__main__")," to call ",Object(o.b)("inlineCode",{parentName:"p"},"init_logging")," (see the\nsection on ",Object(o.b)("inlineCode",{parentName:"p"},"__main__"),")."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"from antlir.common import get_logger\n\nlog = get_logger()\n\n...\nlog.info(f'foo {var}')\n")),Object(o.b)("h3",{id:"formatting-pep-8-80-chars"},"Formatting: PEP-8, 80 chars"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"If you need to churn formatting, do it on a separate diff. Don't mix\nre-formatting with logic changes. Super-small reformats may be begrudgingly\ntolerated."),Object(o.b)("li",{parentName:"ul"},"We don't nitpick formatting, as long as it's lint-clean, see\n",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://our.intern.facebook.com/intern/diffusion/FBS/browse/master/fbcode/antlir/.flake8"}),"fs","_","image/.flake8"),"."),Object(o.b)("li",{parentName:"ul"},"80 chars optimizes for coding and review on smaller screens (laptop, WFH)"),Object(o.b)("li",{parentName:"ul"},"Manual formatting: optimize for readability. Code is read far more than\nwritten."),Object(o.b)("li",{parentName:"ul"},"Auto-formatting, if you must: most of the codebase is single-quoted, so you\ncan use ",Object(o.b)("inlineCode",{parentName:"li"},"black -S -l 80")," to retain ambient style. In new modules, you can\nuse ",Object(o.b)("inlineCode",{parentName:"li"},'"')," if it makes you happy.")),Object(o.b)("h3",{id:"use-path-from-antlirfs_utils-avoid-pathlib"},"Use ",Object(o.b)("inlineCode",{parentName:"h3"},"Path")," from ",Object(o.b)("inlineCode",{parentName:"h3"},"antlir.fs_utils"),", avoid ",Object(o.b)("inlineCode",{parentName:"h3"},"pathlib")),Object(o.b)("h4",{id:"why-path"},"Why ",Object(o.b)("inlineCode",{parentName:"h4"},"Path"),"?"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Linux paths are not ",Object(o.b)("inlineCode",{parentName:"li"},"str"),", they are ",Object(o.b)("inlineCode",{parentName:"li"},"bytes"),"."),Object(o.b)("li",{parentName:"ul"},"Path raises when compared to ",Object(o.b)("inlineCode",{parentName:"li"},"str"),", preventing bugs like ",Object(o.b)("inlineCode",{parentName:"li"},"'a' == b'a'"),"."),Object(o.b)("li",{parentName:"ul"},"Once we adopt Pyre, the type separation should help detect bugs earlier."),Object(o.b)("li",{parentName:"ul"},"It has the syntax sugar of ",Object(o.b)("inlineCode",{parentName:"li"},"pathlib")," without adopting its over-complicated\nand error-prone object model. In ",Object(o.b)("inlineCode",{parentName:"li"},"pathlib")," if you use the wrong class from\nthe hierarchy, your code fails at runtime, in ",Object(o.b)("inlineCode",{parentName:"li"},"Path"),", there is only one\nclass.")),Object(o.b)("h4",{id:"how-to-pathify-code"},"How to ",Object(o.b)("inlineCode",{parentName:"h4"},"Path"),"ify code"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Take and return just ",Object(o.b)("inlineCode",{parentName:"li"},"Path")," in new interfacecs"),Object(o.b)("li",{parentName:"ul"},"Take ",Object(o.b)("inlineCode",{parentName:"li"},"AnyStr")," in old interfaces, and immediately coerce to ",Object(o.b)("inlineCode",{parentName:"li"},"Path")," to\nsimplify manipulations (Postel's law).")),Object(o.b)("h4",{id:"decode-on-path-is-a-code-smell"},Object(o.b)("inlineCode",{parentName:"h4"},".decode()")," on ",Object(o.b)("inlineCode",{parentName:"h4"},"Path")," is a code smell"),Object(o.b)("p",null,"We need this to interface with foreign modules (e.g. ",Object(o.b)("inlineCode",{parentName:"p"},"requests"),"), but in most\nother circumstances, we have primitives for avoiding explicit ",Object(o.b)("inlineCode",{parentName:"p"},".decode()")," calls\nand the associated waste of time fighting with ",Object(o.b)("inlineCode",{parentName:"p"},"str")," vs ",Object(o.b)("inlineCode",{parentName:"p"},"bytes")," issues.\nSpecifically, be aware that:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Path")," supports ",Object(o.b)("inlineCode",{parentName:"li"},"__format__")," letting it be spliced into f-strings and\n",Object(o.b)("inlineCode",{parentName:"li"},"str.format()"),"."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"subprocess")," allows mixing ",Object(o.b)("inlineCode",{parentName:"li"},"Path")," and ",Object(o.b)("inlineCode",{parentName:"li"},"str")," in arguments."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"os")," functions return ",Object(o.b)("inlineCode",{parentName:"li"},"bytes")," when given ",Object(o.b)("inlineCode",{parentName:"li"},"Path"),", but we add methods to\n",Object(o.b)("inlineCode",{parentName:"li"},"Path")," for the common ones, which return ",Object(o.b)("inlineCode",{parentName:"li"},"Path")," instead."),Object(o.b)("li",{parentName:"ul"},"Use ",Object(o.b)("inlineCode",{parentName:"li"},"Path.parse_args")," instead of ",Object(o.b)("inlineCode",{parentName:"li"},"argparse.ArgumentParser.parse_args")," to let\nyour tests pass in ",Object(o.b)("inlineCode",{parentName:"li"},"Path")," (e.g. ",Object(o.b)("inlineCode",{parentName:"li"},"temp_dir()"),")."),Object(o.b)("li",{parentName:"ul"},"Use ",Object(o.b)("inlineCode",{parentName:"li"},"Path.json_dumps")," instead of ",Object(o.b)("inlineCode",{parentName:"li"},"json.dumps")," to transparently serialize\n",Object(o.b)("inlineCode",{parentName:"li"},"Path"),".")),Object(o.b)("h3",{id:"use-context-managers-instead-of-functions-when-appropriate"},"Use context managers instead of functions when appropriate"),Object(o.b)("p",null,"If not already familiar, learn about the virtues of\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization"}),"RAII"),". In\n",Object(o.b)("inlineCode",{parentName:"p"},"antlir"),", we manage a lot of resources -- temporary files & directories, btrfs\nsubvolumes, subprocesses."),Object(o.b)("p",null,"You will often write code that manages resources, and then does something with\nthese resources. In these cases, it's usually best to:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Create each resource in a separate ",Object(o.b)("inlineCode",{parentName:"li"},"@contextmanager")," function (very rarely,\na class)."),Object(o.b)("li",{parentName:"ul"},"Use chained ",Object(o.b)("inlineCode",{parentName:"li"},"with")," statements, or ",Object(o.b)("inlineCode",{parentName:"li"},"ExitStack"),", to sequentialize allocation &\ndestruction of the resources. Specifically, do ",Object(o.b)("strong",{parentName:"li"},"not")," try to manually clean\nup multiple resources with a single ",Object(o.b)("inlineCode",{parentName:"li"},"try: finally"),", you will get it wrong.")),Object(o.b)("p",null,"Things to avoid:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Python destructors that free resources (google for why they are\nproblematic)."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"subprocess.run()"),"-style APIs for managing long-running processes. Just\nprovide a ",Object(o.b)("inlineCode",{parentName:"li"},"Popen"),"-style ",Object(o.b)("inlineCode",{parentName:"li"},"@contextmanager")," right away, and perhaps add\n",Object(o.b)("inlineCode",{parentName:"li"},"run()"),"-style syntax sugar commonly needed. Refactoring out of this design\nmistake can be costly (look at the history of ",Object(o.b)("inlineCode",{parentName:"li"},"antlir/nspawn_in_subvol"),")."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"finally:")," blocks that clean up more than one resources.")),Object(o.b)("p",null,'Advanced readers might ask "what about ',Object(o.b)("inlineCode",{parentName:"p"},"async"),"?\". The general rule is that it's\nacceptable at module level, but we want to avoid infecting the entire codebase\nwith the extra conceptual complexity it entails, so please don't blindly\n",Object(o.b)("inlineCode",{parentName:"p"},"async"),"ify everything up the stack. Find a reasonable point to wait, and/or\nstart a reasoned discussion about the large benefits that broader\n",Object(o.b)("inlineCode",{parentName:"p"},"async"),"ification would bring."),Object(o.b)("h3",{id:"prefer-long-form-args---absolute-names-over-short--p"},"Prefer long-form args (",Object(o.b)("inlineCode",{parentName:"h3"},"--absolute-names"),") over short (",Object(o.b)("inlineCode",{parentName:"h3"},"-P"),")"),Object(o.b)("p",null,"Seriously, there's not even one ",Object(o.b)("inlineCode",{parentName:"p"},"P")," in ",Object(o.b)("inlineCode",{parentName:"p"},"--absolute-names"),"."),Object(o.b)("h3",{id:"use-the---foobar-form-for-long-form-args-when-possible"},"Use the ",Object(o.b)("inlineCode",{parentName:"h3"},"--foo=bar")," form for long-form args when possible"),Object(o.b)("p",null,"The only known exceptions are:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"The target command does not accept the ",Object(o.b)("inlineCode",{parentName:"p"},"=")," form, and requires two separate\narguments.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"The option takes multiple arguments. Then, the suggested form is:"),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"subprocess.Popen([\n    '--one-arg=foo',\n    # Group to prevent `black` from putting this on 3 lines\n    *('--multi-arg', 'bar', baz'),\n])\n")))),Object(o.b)("p",null,"Note that ",Object(o.b)("inlineCode",{parentName:"p"},"*()")," is ",Object(o.b)("strong",{parentName:"p"},"not")," mandatory, use it only when it makes it easier to\nunderstand the grouping."),Object(o.b)("p",null,"Why have a convention at all? First, we can more easily adopt syntax sugar for\nour convention (e.g. this motivated ",Object(o.b)("inlineCode",{parentName:"p"},"Path.__format__"),"). Also, uniformity can\nhelp readability."),Object(o.b)("p",null,"Why use one arg with ",Object(o.b)("inlineCode",{parentName:"p"},"=")," instead of two separate args?"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Most importantly, it is clear at a glance that an option takes an argument.\nReading ",Object(o.b)("inlineCode",{parentName:"p"},"['--foo', bar, baz]")," leaves ambiguity, ",Object(o.b)("inlineCode",{parentName:"p"},"['--foo={bar}', baz]")," does\nnot.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Repeated arguments are cleaner, you can do ",Object(o.b)("inlineCode",{parentName:"p"},"[*['--i={i}' for i in range(3)],\n'-b']")," instead of flattening nested lists.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"With separate arguments, ",Object(o.b)("inlineCode",{parentName:"p"},"black")," formats them one-per-line, which often\nresults in over-long functions for no benefit.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Although separate args line-wrap naturally, with ",Object(o.b)("inlineCode",{parentName:"p"},"=")," you can easily get\nline-wrapping via ",Object(o.b)("inlineCode",{parentName:"p"},"+"),", e.g.:"),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"'--a-long-option-name='\n    + 'its value',\n")))),Object(o.b)("h3",{id:"respect-private-identifiers"},"Respect private identifiers"),Object(o.b)("p",null,"Conventionally, private Python identifiers start with ",Object(o.b)("inlineCode",{parentName:"p"},"_"),", and should not be\nused outside the module, or its test. A module can span multiple files (like\n",Object(o.b)("inlineCode",{parentName:"p"},"nspawn_in_subvol"),"), the point is to respect abstraction boundaries and not leak\nimplementation details."),Object(o.b)("p",null,"As another example, do not use ",Object(o.b)("inlineCode",{parentName:"p"},"debug_only_opts")," from ",Object(o.b)("inlineCode",{parentName:"p"},"nspawn_in_subvol")," in any\ncode that runs on ",Object(o.b)("inlineCode",{parentName:"p"},"buck build"),", ",Object(o.b)("inlineCode",{parentName:"p"},"buck test"),", or automation. This feature set is\nreally just for interactive debugging by humans via the CLI. Don't use it in\nother code!"),Object(o.b)("h3",{id:"limit-positional-args-to-2-use-keyword-only-args-pos--kw1-kw2"},"Limit positional args to 2, use keyword-only args (",Object(o.b)("inlineCode",{parentName:"h3"},"pos, *, kw1, kw2"),")"),Object(o.b)("p",null,"Callsites using many positional arguments are harder to read & understand -- it\nis rare that an action takes more than 2 obviously ordered objects. In rare\ncases, 3 positional args are OK."),Object(o.b)("p",null,"On the flip side, callsites with keyword arguments are much easier to maintain.\nYou can safely change the signature in the following ways:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Add more (defaulted) arguments"),Object(o.b)("li",{parentName:"ul"},"Reorder arguments"),Object(o.b)("li",{parentName:"ul"},"Remove or rename arguments, only updating the callsites that explicitly\nmention them (i.e. ",Object(o.b)("inlineCode",{parentName:"li"},"hg grep kwarg="),")")))}b.isMDXComponent=!0}}]);